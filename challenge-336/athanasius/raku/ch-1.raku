use v6d;

################################################################################
=begin comment

Perl Weekly Challenge 336
=========================

TASK #1
-------
*Equal Group*

Submitted by: Mohammad Sajid Anwar

You are given an array of integers.

Write a script to return true if the given array can be divided into one or more
groups: each group must be of the same size as the others, with at least two
members, and with all members having the same value.

Example 1

  Input: @ints = (1,1,2,2,2,2)
  Output: true

  Groups: (1,1), (2,2), (2,2)

Example 2

  Input: @ints = (1,1,1,2,2,2,3,3)
  Output: false

  Groups: (1,1,1), (2,2,2), (3,3)

Example 3

  Input: @ints = (5,5,5,5,5,5,7,7,7,7,7,7)
  Output: true

  Groups: (5,5,5,5,5,5), (7,7,7,7,7,7)

Example 4

  Input: @ints = (1,2,3,4)
  Output: false

Example 5

  Input: @ints = (8,8,9,9,10,10,11,11)
  Output: true

  Groups: (8,8), (9,9), (10,10), (11,11)

=end comment
################################################################################

#--------------------------------------#
# Copyright © 2025 PerlMonk Athanasius #
#--------------------------------------#

#===============================================================================
=begin comment

Interface
---------
1. If no command-line arguments are given, the test suite is run. Otherwise:
2. A non-empty list of integers is entered on the command-line.
3. If the first integer is negative, it must be preceded by "--" to indicate
   that it is not a command-line flag.

Algorithm
---------
The integers in the input list are merely markers -- they could just as well be
characters or words. The order in which they appear is also irrelevant. What
matters is the frequency with which they appear in the list:

(1) If any list element occurs only once, no solution is possible.

(2) Otherwise, a solution is possible if and only if the frequencies share a
    common divisor greater than 1. This gives rise to the following algorithm:

    1. For each element in the list, find its frequency, f.
    2. For each f, find the bag (multiset) containing the prime factors of f.
    3. Find X, the intersection of all bags found in step 2.
    4. If X is empty, no solution is possible.
    5. Otherwise, find p, the product of all the members of X.
    6. A solution may now be generated by partitioning the elements of the
       original list into same-element bags, each of size p.

=end comment
#===============================================================================

use Test;

subset Result of List where (Bool, Array[Array[Int]]);

#-------------------------------------------------------------------------------
BEGIN
#-------------------------------------------------------------------------------
{
    "\nChallenge 336, Task #1: Equal Group (Raku)\n".put;
}

#===============================================================================
multi sub MAIN
(
    #| A non-empty list of integers

    *@ints where { .elems > 0 && .all ~~ Int:D }
)
#===============================================================================
{
    "Input:  \@ints = (%s)\n".printf: @ints.join: ',';

    my Result $result = equal-groups( @ints );

    "Output: %s\n".printf: $result[ 0 ] ?? 'true' !! 'false';

    if $result[ 0 ]
    {
        "\nGroups: %s\n".printf:
            $result[ 1 ].map( { '(' ~ .join( ',' ) ~ ')' } ).join: ', ';
    }
}

#===============================================================================
multi sub MAIN()                                  # No input: run the test suite
#===============================================================================
{
    run-tests();
}

#-------------------------------------------------------------------------------
sub equal-groups( List:D[Int:D] $ints --> Result:D )
#-------------------------------------------------------------------------------
{
    my Array[Int] @groups;
    my Bool $result = False;
    my UInt %count{Int};
          ++%count{ +$_ } for @$ints;
    my UInt @counts = %count.values.sort;

    if @counts[ 0 ] > 1    # If the smallest count is 1, no solution is possible
    {
        my BagHash[Int] $common-factors = BagHash[Int].new;
                        $common-factors.add: $_ for factor( @counts[  0 ] );

        for 1 .. @counts.end -> UInt $i
        {
            my BagHash[Int]    $factors = BagHash[Int].new;
                               $factors.add: $_ for factor( @counts[ $i ] );

            # Keep only the intersection
            $common-factors = BagHash[Int].new-from-pairs:
                             ($common-factors ∩ $factors).list;
        }

        my UInt @factors = $common-factors.kxxv.sort;

        if @factors.elems > 0
        {
            $result = True;
            @groups = make-groups( %count, @factors );
        }
    }

    return $result, @groups;
}

#-------------------------------------------------------------------------------
sub make-groups
(
    Hash:D         $count,
    List:D[UInt:D] $factors
--> Array:D[Array:D[Int:D]]
)
#-------------------------------------------------------------------------------
{
    my Array[Int] @groups;

    my UInt $product  = 1;
            $product *= $_ for @$factors;

    for $count.keys.sort -> Int $n
    {
        my UInt $multiplier = $count{ $n } div $product;

        push @groups, Array[Int].new: $n xx $product for 1 .. $multiplier;
    }

    return @groups;
}

#-------------------------------------------------------------------------------
sub factor( UInt:D $int --> List:D[UInt:D] )
#-------------------------------------------------------------------------------
{
    # Code adapted from "Finding prime factors using Raku" by Andrew Shitov,
    # https://andrewshitov.com/2019/09/09/finding-prime-factors-using-perl-6/

    my Rat  $n      = $int.Rat;
    my UInt @primes = grep { .is-prime }, 1 .. *;
    my UInt $pos    = 0;
    my UInt @factors;

    while $n > 1
    {
        my UInt $factor = @primes[ $pos++ ];

        next unless $n %% $factor;

        $pos = 0;
        $n  /= $factor;

        @factors.push: $factor;
    }

    return @factors;
}

#-------------------------------------------------------------------------------
sub run-tests()
#-------------------------------------------------------------------------------
{
    'Running the test suite'.put;

    for test-data.lines -> Str $line
    {
        my Str ($test-name, $ints-str, $expected-str, $groups-str) =
                $line.split: / \| /;

        for     $test-name, $ints-str, $expected-str, $groups-str
        {
            s/ ^ \s+   //;
            s/   \s+ $ //;
        }

        my Int    @ints       = $ints-str.split( / \s+ /, :skip-empty )
                                         .map: { .Int };
        my Result $result     = equal-groups( @ints );
        my Bool   $expected   = $expected-str eq 'true';
        my Str    @group-str  = $groups-str.split: / \; \s* /, :skip-empty;
        my Array[Int] @groups = @group-str.map:
                                {
                                    Array[Int].new:
                                    .split( / \s+ /, :skip-empty ).map: { .Int }
                                };

        is        $result[ 0 ], $expected, "$test-name: Result";
        is-deeply $result[ 1 ], @groups,   "$test-name: Groups" if $result[ 0 ];
    }

    done-testing;
}

#-------------------------------------------------------------------------------
sub USAGE()
#-------------------------------------------------------------------------------
{
    my Str $usage = $*USAGE;

    $usage ~~ s:g/ ($*PROGRAM-NAME) /raku $0/;

    $usage.put;
}

#-------------------------------------------------------------------------------
sub test-data( --> Str:D )
#-------------------------------------------------------------------------------
{
    return q:to/END/;
        Example 1|1 1 2 2 2 2            |true |1 1; 2 2; 2 2
        Example 2|1 1 1 2 2 2 3 3        |false|1 1 1; 2 2 2; 3 3
        Example 3|5 5 5 5 5 5 7 7 7 7 7 7|true |5 5 5 5 5 5; 7 7 7 7 7 7
        Example 4|1 2 3 4                |false|
        Example 5|8 8 9 9 10 10 11 11    |true |8 8; 9 9; 10 10; 11 11
        END
}

################################################################################
