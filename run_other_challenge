#!/usr/bin/env perl
#
#


use Test2::V0 qw( -no_srand );
use Data::Dump qw( pp );

my %translations = (
    'adam-russel' => { SUB => "is_square" };
);

for my $perl_file ( @ARGV ) {
    my $name = do { $perl_file =~ /([^\/]+)\/perl/; $1 };
    note "\n", "Testing $name\n", "\n";

    # Load the source file, for function definitions.
    # Redirect STDOUT temporarily.
    {
	local *STDOUT;
	open STDOUT, ">", "/dev/null"
	    or die "Can't open /dev/null: $!";
	eval {
	    require "$perl_file";
	};
	warn $@ if $@;
    }

    $sub_name = $translations{$name}{SUB};

    # This runs the tests for the sub named "$sub_name"
    run_test( $sub_name, $_->@* )
	for @tests;
}




my $sub_name = "consecutive_sequence";
my @tests = (
    [ 'Example 1:', [ 10, 4, 20, 1, 3, 2 ], 4 ],
    [ 'Example 2:', [ 0, 6, 1, 8, 5, 2, 4, 3, 0, 7 ], 9 ],
    [ 'Example 3:', [ 10, 30, 20 ], -1 ],
);

sub run_test( $sub, $descr, $input, $output ) {
    if ( ! ref $output && $output =~ /^(?:(true)|false)$/i ) {
        my $expected_true = $1;
        $descr .=
            " $sub( " . join( ", ", map pp( $_ ), $input->@* ) . " )"
            . " is $output"
            if substr( $descr, -1, 1 ) eq ":";
        no strict 'refs';
        $expected_true
        ? ok $sub->( $input ), $descr
        : ok ! $sub->( $input ), $descr;
    }
    else {
        $descr .= " " . pp( $input ) . " => $output"
            if substr( $descr, -1, 1 ) eq ":";
        no strict 'refs';
        my @input = ref $input ? $input->@* : ( $input );
        is $sub->( @input ), $output, $descr;
    }
}

done_testing;
