#!/usr/bin/env perl
#
#	download_challenge [<challenge> ...]
#		checks whether there is a new weekly challenge, extracts
#		the new task descriptions if so,
#		writes them as ascii into a text file,
#		and sends them via HTML email.
#
#	Usage:
#	    get_weekly_challenge
#		Retrieves the task descriptions for the most recent weekly
#		challenge, copies them as a text file into the
#		../challenge-<challenge>/matthias-muth/perl directory,
#		and sends an email to a default list of recipients.
#	    get_weekly_challenge <challenge> ...
#		Retrieves the task descriptions for the given challenges
#		and copies them as text files into the
#		../challenge-<challenge>/matthias-muth/perl directories.
#		No mail is sent unless the -mail <recipient> option is
#		given explicitly.
#	Options:
#	    -nomail | -nom
#		Do not send emails.
#	    -nofile | -nof
#	        Do not write a text file with the challenge tasks.
#	    -mail <recipient>
#		Send mail (or mails) to <recipient>.
#		The default list of recipients is not used if this option is
#		given.
#		This option can be used multiple times.
#

use strict;
use warnings;

use M;
use Getopt::Long;
use TOML;
use Time::Piece;

use LWP::Simple;
use HTML::TreeBuilder::XPath;
use URI::Escape;
use Encode;

use File::Basename;
use File::Path qw( make_path );

use Digest::MD5 qw( md5_hex );
use Email::Stuffer;


sub usage {
    say STDERR "Usage!";
    exit 2;
};

GetOptions(
    "force|f!"               => \$options{FORCE},
    "check|n"                => \$options{DRY_RUN},
    "mail|m:s@"              => \$options{MAIL_TO},
    "nomail|nom"             => sub {
				    # Make sure it's defined but empty.
				    $options{MAIL_TO} = [];
				},
    "nofile|nof"             => \$options{NO_FILE},
    "quiet|q!"               => \$options{QUIET},
    "verbose|v!"             => \$verbose,
    "help|?"                 => \&usage,
) or do {
    say STDERR
        "    Use '$0 -help' for usage information.";
    exit 2;
};

# Read 'status.toml', keep it as a global variable.
our $status = read_toml( "status.toml" );

# Defaults:
unless ( @ARGV ) {
    # We use the following option to decide whether to check the challenge's
    # html checksum.
    $options{CHALLENGE_UPDATE_ONLY} = 1;

    # Send mail to default recipients if no challenge arguments are given.
    $options{MAIL_TO} //= $status->{'recipients'};
}

process_challenge( $_ )
    for @ARGV ? @ARGV : get_challenge_update();

# Update the status toml file.
write_toml( $status )
    unless $options{DRY_RUN};

exit 0;

sub process_challenge( $challenge ) {

    # Extract the interesting portion from the challenge page.
    my $title = "Perl Weekly Challenge $challenge";

    # Get variable HTML parts from the challenge page.
    my ( $main_url, $challenge_path ) =
	@$status{ qw( main-url challenge-path ) };
    $challenge_path =~ s/\d+/$challenge/;

    my $html = get( $main_url . $challenge_path );
    # my $html = slurp_file( "challenge.html" );

    my ( $page_header ) = 
	$html =~ m'(<section class="global-page-header">.*?</section>)'s;
    # vsay "page_header:\n", $page_header;

    my ( $tasks ) =
	$html =~ m'(<h2 id="TASK1">.*?</section>)'s;
    # vsay "tasks:\n", pp( $tasks );

    my $template = read_toml( "template.toml" );
    $html = join "\n",
	$template->{'mail'}{'document-start'},
	${page_header},
	$template->{'mail'}{'section-start'},
	${tasks},
	$template->{'mail'}{'document-end'};
    $html =~ s((<title>.*?)\d+(</title>))(${1}${challenge}${2}r);
    # vsay "html\n", $html;

    unless ( $html ) {
	say STDERR "ERROR: html is empty. Aborting.";
	exit 1;
    }

    # Send mails.
    if ( $options{MAIL_TO} && @{$options{MAIL_TO}} ) {
	# For updates, send mails only if the html text has changed.
	my $send_html = 1;
	if ( $options{CHALLENGE_UPDATE_ONLY} ) {
	    if ( ( my $md5 = md5_hex( $html ) )
		eq $status->{'challenge-html-md5'} )
	    {
		vsay "html md5 has not changed";
		$send_html = 0;
	    }
	    else {
		vsay "html md5 has changed";
		set_toml( $status, 'challenge-html-md5', $md5 );
	    }
	}

	if ( $send_html ) {
	    for my $rcpt ( @{$options{MAIL_TO}} ) {
		if ( $options{DRY_RUN} ) {
		    say "not sending email to $rcpt"
			unless $options{QUIET};
		}
		else {
		    vsay "sending email to $rcpt";
		    Email::Stuffer
			->from( 'muthm@muthnet.de' )
			->to( $rcpt )
			->subject( $title )
			->html_body( $html )
			->send_or_die;
		    prot "Sent email to $rcpt"
			unless $options{QUIET};
		}
	    }
	}
    }

    unless ( $options{NO_FILE} ) {
	my $tree = HTML::TreeBuilder::XPath->new( ignore_unknown => 0 );

	$tree->parse_content( $html )
	    or die "ERROR: could not parse html data.\n";

	# Extract nodes containing the title and the date,
	# followed by two <br> to create empty lines,
	# followed by everything inside the <div class="post-content"> block,
	# individually.
	my @nodes = map $tree->findnodes( $_ ),
	    qw(
		//section[@class="global-page-header"]//h2
		//div[@class="block"]//span[1]
		//br[1]
		//br[1]
		//div[@class="post-content"]/*
	    );
	# Extract the text from the nodes.
	# Ignore <hr> to avoid empty lines where they are not needed.
	# Instead add an extra empty line after <h4> ('Example...') and
	# <h5> ('submitted by'). 
	my $challenge_text = join "",
	    map { $_->as_text . "\n" . ( $_->{_tag} =~ /^h[45]/ ? "\n" : "" ) }
	        grep $_->{_tag} ne "hr", @nodes;
	my $target_dir = "../challenge-$challenge/matthias-muth/perl";
	vsay $challenge_text;
	vsay 
	    $options{DRY_RUN} ? "not " : "",
	    "writing '$target_dir/challenge-$challenge.txt'";
	unless ( $options{DRY_RUN} ) { 
	    make_path $target_dir;
	    spit_file( "$target_dir/challenge-$challenge.txt",
		$challenge_text );
	}
    }
}

exit 0;

sub slurp_file( $file ) {
    open my $fh, "<", $file
	or die "cannot open '$file': $!\n";
    my $text = do { local $/ = undef; <$fh> };
    close $fh;
    return $text;
}

sub spit_file( $file, $text ) {
    open my $fh, ">", $file
	or die "cannot open '$file' for writing: $!\n";
    print $fh $text;
    close $fh;
}

sub get_href( $base_url, $pattern ) {
    my $tree = HTML::TreeBuilder::XPath->new_from_url( $base_url )
	or die "ERROR: could not retrieve data from $base_url.\n";
    my $xpath  = "//\@href[.=~/$pattern/";
    my $link = $tree->findvalue( $xpath )
	or die "ERROR: did not find xpath '$xpath' in data.\n";
    return $link;
}

sub get_challenge_update {

    # TODO:
    # Return the text of the challenge.
    # Compare modification time of challenge page to determine if there is an
    # updated version of the page that we already have retrieved.
    # Keep a checksum of the extracted text for this. 

    my ( $challenge ) = $status->{'challenge-path'} =~ /(\d+)/;

    # Step 1:
    # Determine the current challenge number:
    # Check whether the main page was modified.
    # Update to the current challenge number if it has.
    # If no change was detected, use what we have cached in status.toml.

    my $main_url = $status->{'main-url'};
    my $challenge_path = $status->{'challenge-path'};
    if ( check_page_change( $main_url, 'main-last-modified' ) ) {
	my $xpath_pattern  = '\/blog\/perl-weekly-challenge-\\d+';
	$challenge_path = get_href( $main_url, $xpath_pattern );
	vsay "challenge-path: ", pp( $challenge_path );
	unless ( $challenge_path ) {
	    say STDERR "ERROR: Could not extract challenge url. Aborting.";
	    exit 1;
	}

	if ( $challenge_path ne $status->{'challenge-path'} ) {
	    ( $challenge ) = $challenge_path =~ /(\d+)$/;
	    prot "New challenge $challenge detected."
		unless $options{QUIET};
	    set_toml( $status, "challenge-path", $challenge_path );
	    set_toml( $status, "challenge-last-modified", "" );
	}
	else {
	    vsay "challenge url has not changed";
	}
    }
    else {
	vsay "main page was not modified";
    }

    # Step 2:
    # Check the challenge page for modification.
    if ( ! check_page_change(
	$main_url . $challenge_path, 'challenge-last-modified' ) )
    {
        vsay "challenge was not modified";
	$challenge = undef;
    }
    else {
	vsay "challenge page was modified";
    }

    return $challenge // ();
}

sub check_page_change( $url, $last_modified_field_name ) {
    my @header = head( $url );
    my $modified_time = time_string( $header[2] );
    vsay "modified_time: ", pp( $modified_time );
    if ( $status->{$last_modified_field_name} 
	&& $modified_time eq $status->{$last_modified_field_name} )
    {
	# vsay "'$url' was not modified";
	return ()
	    unless $options{FORCE};
    }
    set_toml( $status, $last_modified_field_name, $modified_time );
    return 1;
}

sub time_string( $time ) {
    my $time_struct = localtime( $time );
    my $time_string = $time_struct->strftime( "%FT%T%z" );
    # Insert a ':' between the time zone hours and minutes to be RFC 3339
    # compatible (which is what TOML promotes), even if ISO allows time zones
    # without ':'. Actually with no real effect, since Perl TOML doesn't
    # convert datetime strings if no 'inflate_datetime' subroutine is given
    # to the TOML parser. So we will get the string back that we store.
    $time_string =~ s/(?=\d{2}$)/:/;
    return $time_string;
}

sub read_toml( $filename ) {
    my $toml_text = slurp_file( $filename );
    my $hash_ref = TOML::from_toml( $toml_text );
    # Keep the filename and the toml text for later writing back the file.
    @$hash_ref{ qw( TOML_FILE TOML_TEXT ) } = ( $filename, $toml_text );
    return $hash_ref;
}

sub write_toml( $hash_ref ) {
    my ( $filename, $toml_text ) = @$hash_ref{ qw( TOML_FILE TOML_TEXT ) };
    # Update the toml file if needed.
    spit_file( $filename, $toml_text )
	if $hash_ref->{TOML_CHANGED} && ! $options{DRY_RUN};
    delete $hash_ref->{TOML_CHANGED};
}

sub set_toml( $hash_ref, $name, $value ) {
    $hash_ref->{$name} = $value;
    $hash_ref->{TOML_TEXT} =~ s/^(\s* ${name} \s* = \s* ).*?$/${1}"${value}"/xm;
    $hash_ref->{TOML_CHANGED} = 1;
}

1;
