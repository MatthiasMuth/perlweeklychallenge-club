#!/usr/bin/env perl
#
#	download_challenge [<challenge> ...]
#		checks whether there is a new weekly challenge, extracts
#		the new task descriptions if so,
#		writes them as ascii into a text file,
#		and sends them via HTML email.
#		It also generates skeleton files for perl/ch-[12].pl based on
#		the challenge task descriptions.
#
#	Usage:
#	    get_weekly_challenge
#		Without parameters, executes these default tasks:
#		  * retrieve the task descriptions for the most recent weekly
#		    challenge from the Weekly Challenge website.
#	        If the challenge number or the task descriptions have changed:
#		  * write a text file 'challenge-<challenge>.txt' containing the
#		    task descriptions in the
#		    .../challenge-<challenge>/<user>/perl directory,
#		    if the task descriptions have changed,
#		    (where <user> is the challenge user name, as specified in
#		    the 'status.toml' file),
#		  * send the task descriptions as html email to a default list
#		    of recipients (specified in 'status.toml').
#		  * generate skeleton files for .../perl/ch-[12].pl based on
#		    the challenge task descriptions, if they do not yet exist.
#
#	    get_weekly_challenge <challenge> ...
#		When challenge numbers are explicitly given as command line
#		parameters, only these steps are done by default:
#		  * retrieve the task descriptions for the given challenges,
#		  * write the task text files if they have changed,
#		  * generate the code skeleton files if they do not yet exist.
#		No mail is sent unless the -mail <recipient> option is
#		given explicitly.
#
#	Options:
#	    -nofiles | -nof
#	        Do not write any output files.
#	    -mail <recipient>
#		Send mail (or mails) to <recipient>.
#		The default list of recipients is not used if this option is
#		given.
#		This option can be used multiple times.
#	    -nomail | -nom
#		Do not send any default emails.
#

use strict;
use warnings;

use M;
use Getopt::Long qw( :config no_ignore_case );
use TOML;
use Time::Piece;

use LWP::Simple;
use HTML::TreeBuilder::XPath;
use URI::Escape;
use Encode;

use File::Basename;
use File::Path qw( make_path );

use Digest::MD5 qw( md5_hex );
use Email::Stuffer;


sub usage {
    say STDERR "Usage!";
    exit 2;
};

GetOptions(
    "force|f!"               => sub {
				   $options{FORCE} =
				    $_[1] ? ++$options{FORCE} : 0;
				},
    "FORCE|F"                => sub { $options{FORCE} = 2 },
    "check|n"                => \$options{DRY_RUN},
    "mail|m:s@"              => \$options{MAIL_TO},
    "nomail|nom"             => sub {
				    # Make sure it's defined but empty.
				    $options{MAIL_TO} = [];
				},
    "nofile|nof"             => \$options{NO_FILE},
    "quiet|q!"               => \$options{QUIET},
    "verbose|v!"             => \$verbose,
    "help|?"                 => \&usage,
) or do {
    say STDERR
        "    Use '$0 -help' for usage information.";
    exit 2;
};

$options{FORCE} //= 0;

# Read 'status.toml' and templates, keep it as a global variable.
our $status   = read_toml( "status.toml" );
our $templates = read_toml( "templates.toml" );

# Defaults:
unless ( @ARGV ) {
    # We use the following option to decide whether to always send mails
    # or only when there was a change.
    # Also, for updates of the most recent challenge, we need to keep track of
    # the modification times and md5 checksums.
    # We do not do that if the challenge numbers are given explicitly.
    $options{UPDATE} = 1;

    # Send mail to default recipients if no challenge arguments are given.
    $options{MAIL_TO} //= $status->{'recipients'};
}

process_challenge( $_ )
    for @ARGV ? @ARGV : get_challenge_update();

# Update the status toml file.
write_toml( $status )
    if $options{UPDATE} && ! $options{DRY_RUN};

exit 0;

sub process_challenge( $challenge ) {

    # Extract the interesting portion from the challenge page.
    my $title = "Perl Weekly Challenge $challenge";

    # Extract relevant HTML parts (page header and task descriptions)
    # from the challenge page.
    my ( $main_url, $challenge_path ) =
	@$status{ qw( main-url current-challenge-path ) };
    $challenge_path =~ s/\d+/$challenge/;
    my $html = get( $main_url . $challenge_path );
    my ( $page_header ) = 
	$html =~ m'(<section class="global-page-header">.*?</section>)'s;
    my ( $tasks ) =
	$html =~ m'(<h2 id="TASK1">.*?</section>)'s;

    # Create the mail html from the template,
    # copying in the extracted HTML parts.
    $html = $templates->{'mail'}{'html'};
    my %substitutions = (
	CHALLENGE   => $challenge,
	PAGE_HEADER => $page_header,
	TASKS       => $tasks,
    );
    $html =~ s/<$_>/$substitutions{$_}/g
	for keys %substitutions;
    # vsay "html\n", $html;

    unless ( $html ) {
	say STDERR "ERROR: html is empty. Aborting.";
	exit 1;
    }

    # If we are running an updates, check whether challenge html has changed.
    my $md5 = md5_hex( $html );
    my $html_has_changed = undef;
    if ( $options{UPDATE} ) {
	$html_has_changed = $md5 ne $status->{'current-challenge-html-md5'};
	if ( $html_has_changed ) {
	    vsay "curent md5: $status->{'current-challenge-html-md5'}";
	    prot "Task description html has changed (md5:$md5)"
		unless ! $status->{'current-challenge-html-md5'};
	    set_toml( $status, 'current-challenge-html-md5', $md5 );
	}
	else {
	    prot "Task description html is unchanged."
		unless $options{QUIET};
	}
    }
    else {
	vsay "Task description will be used unconditionally.";
    }

    # Send mails.
    # For updates, send mails only if the html text has changed.
    if ( ( ! $options{UPDATE} || $html_has_changed )
       && $options{MAIL_TO} && @{$options{MAIL_TO}} )
    {
	for my $rcpt ( @{$options{MAIL_TO}} ) {
	    my $msg = "sending email to $rcpt";
	    if ( $options{DRY_RUN} ) {
		say $msg;
	    }
	    else {
		vsay $msg;
		Email::Stuffer
		    ->from( 'muthm@muthnet.de' )
		    ->to( $rcpt )
		    ->subject( $title )
		    ->html_body( $html )
		    ->send_or_die;
		prot "Sent email to $rcpt"
		    unless $options{QUIET};
	    }
	}
    }

    # Write files.
    unless ( $options{NO_FILE} ) {
	my $tree = HTML::TreeBuilder::XPath->new( ignore_unknown => 0 );

	$tree->parse_content( $html )
	    or die "ERROR: could not parse html data.\n";

	# Extract nodes containing the title and the date,
	# followed by two <br> to create empty lines,
	# followed by everything inside the <div class="post-content"> block,
	# individually.
	my @nodes = map $tree->findnodes( $_ ),
	    qw(
		//section[@class="global-page-header"]//h2
		//div[@class="block"]//span[1]
		//br[1]
		//br[1]
		//div[@class="post-content"]/*
	    );

	# Extract the text from the nodes.
	# Ignore <hr> to avoid empty lines where they are not needed.
	# Instead add an extra empty line after <h4> ('Example...') and
	# <h5> ('submitted by'). 
	my $challenge_text = join "",
	    map { $_->as_text . "\n" . ( $_->{_tag} =~ /^h[45]/ ? "\n" : "" ) }
	        grep $_->{_tag} ne "hr", @nodes;

	# Generate the code skeletons.
	my ( $task_1, $task_2 ) = $challenge_text =~ /(^Task 1.*)(^Task 2.*)/ms;
	my ( $task_1_code, $task_2_code ) =
	    map generate_code( $challenge, $_ ), ( $task_1, $task_2 );

	# Generate README.md.
	my $readme_text = generate_readme_md( $challenge, $challenge_text );

	# Generate blog.txt
	my $blog_text = $templates->{readme}{blog_txt};
	$blog_text =~ s/<CHALLENGE>/$challenge/g;

	# Write out
	#  - a local archive copy of the html if the html has changed,
	#  - the task descriptions text file,
	#  - the code files, not overwriting them if they already exist.
	#  - a copy of TestExtractor.pm if it doesn't exist yet.
	my $archive_dir = "./challenge_htmls/$challenge";
	# my $archive_file = timestamp() . "_$md5";
	my $archive_file =
	    $status->{'current-challenge-last-modified'} . "_$md5";
	$archive_file =~ s/[-:]//g;
	my $target_dir = "../challenge-$challenge/$status->{user}";
	my $test_extractor_file = "$target_dir/perl/TestExtractor.pm";

	my @file_operations =
	    ( ! $options{UPDATE} || $html_has_changed || $options{FORCE} )
	    ? (
		$options{UPDATE}
		    ? [ "$archive_dir/$archive_file", $html ]
		    : (),
		[ "$target_dir/README-$challenge.md",
		    $readme_text, 'DO_NOT_OVERWRITE' ],
		[ "$target_dir/blog.txt",
		    $blog_text, 'DO_NOT_OVERWRITE' ],
		[ "$target_dir/perl/challenge-$challenge.txt",
		    $challenge_text ],
		[ "$target_dir/perl/ch-1.pl",
		    $task_1_code, 'DO_NOT_OVERWRITE' ],
		[ "$target_dir/perl/ch-2.pl",
		    $task_2_code, 'DO_NOT_OVERWRITE' ],
		[ $test_extractor_file,
		    slurp_file( "./TestExtractor.pm" ), 'DO_NOT_OVERWRITE' ],
	    ) : ();

	for ( @file_operations ) {
	    my ( $file, $contents, $do_not_overwrite ) = @$_;
	    my %verb_form =
		$options{DRY_RUN}
		?  ( write => "write", overwrite => "overwrite" )
		:  ( write => "writing", overwrite => "overwriting" );
	    my $msg =
		( $options{DRY_RUN} ? "would " : "" )
		. ( ( -f $file && $do_not_overwrite && $options{FORCE} < 2 )
		    ? "not " : "" )
		. ( -f $file
		    ? ( ( ( $do_not_overwrite && $options{FORCE} >= 2 )
			    ? "forcefully " : "" )
			. $verb_form{"overwrite"} )
		    : $verb_form{"write"} )
		. " '$file'";
	    vsay $msg;
	    unless ( $options{DRY_RUN} ) {
		make_path dirname( $file );
		spit_file( $file, $contents )
		    unless -f $file && $do_not_overwrite && $options{FORCE} < 2;
		chmod 0755, $file
		    if $file =~ /.pl$/;
	    }
	}
    }
}

exit 0;

sub retrieve_challenge_link( $base_url, $pattern ) {
    my $tree = HTML::TreeBuilder::XPath->new_from_url( $base_url )
	or die "ERROR: could not retrieve data from $base_url.\n";
    my $xpath  = "//\@href[.=~/$pattern/";
    my $link = $tree->findvalue( $xpath )
	or die "ERROR: did not find xpath '$xpath' in data.\n";
    return $link;
}

sub get_challenge_update {

    # Return the current challenge number if there needs to be an update,
    # or the new challenge number if it has changed.
    # Otherwise return nothing.

    my ( $challenge ) = $status->{'current-challenge-path'} =~ /(\d+)/;

    # Step 1:
    # Determine the current challenge number:
    # Check whether the main page was modified.
    # Update to the current challenge number if it has.
    # If no change was detected, use what we have cached in status.toml.

    my $main_url = $status->{'main-url'};
    my $challenge_path = $status->{'current-challenge-path'};
    if ( check_page_change( $main_url, 'main-last-modified' ) ) {
	my $xpath_pattern  = '\/blog\/perl-weekly-challenge-\\d+';
	$challenge_path = retrieve_challenge_link( $main_url, $xpath_pattern );
	vsay "current-challenge-path: ", pp( $challenge_path );
	unless ( $challenge_path ) {
	    say STDERR "ERROR: Could not extract challenge url. Aborting.";
	    exit 1;
	}

	if ( $challenge_path ne $status->{'current-challenge-path'} ) {
	    ( $challenge ) = $challenge_path =~ /(\d+)$/;
	    prot "New challenge $challenge detected."
		unless $options{QUIET};
	    set_toml( $status, "current-challenge-path", $challenge_path );
	    set_toml( $status, "current-challenge-last-modified", "" );
	    set_toml( $status, "current-challenge-html-md5", "" );
	    return $challenge;
	}
	else {
	    vsay "challenge url has not changed";
	}
    }
    else {
	vsay "main page was not modified";
    }

    # Step 2:
    # Check the challenge page for modification.
    if ( check_page_change(
	$main_url . $challenge_path, 'current-challenge-last-modified' ) )
    {
	vsay "challenge page was modified";
	return $challenge;
    }
    else {
        vsay "challenge page was not modified";
	return ();
    }
}

sub check_page_change( $url, $last_modified_field_name ) {
    my @header = head( $url );
    my $modified_time = time_string( $header[2] );
    vsay "modified_time: ", pp( $modified_time );
    if ( $status->{$last_modified_field_name} 
	&& $modified_time eq $status->{$last_modified_field_name} )
    {
	# vsay "'$url' was not modified";
	return ()
	    unless $options{FORCE};
    }
    set_toml( $status, $last_modified_field_name, $modified_time );
    return 1;
}

sub generate_code( $challenge, $task_text ) {

    my ( $task, $task_name ) = $task_text =~ /^Task (\d+):\s*(.*?)\s*$/m;

    use TestExtractor;
    my @tests = TestExtractor::extract_tests( $task_text );

    my $code = $templates->{code}{'ch-N_pl'};
    ( my $sub_name = lc $task_name ) =~ s/\W+/_/g;
    my @input_vars = @{$tests[0]{VARIABLE_NAMES}};

    # Turn array parameters into arrayrefs in some cases.
    if ( @input_vars > 1
	|| ref $tests[0]{INPUT}[0] eq 'ARRAY'
	    && ref $tests[0]{INPUT}[0][0] eq 'ARRAY' )
    {
	substr $_, 0, 1, '$'
	    for @input_vars;
    }
    my $input_params = join ", ", @input_vars;
    my $result_var = 
	ref $tests[0]{OUTPUT} eq 'ARRAY'
	? '@results'
	: '$result';
    my $return = 
	ref $tests[0]{OUTPUT} eq 'ARRAY'
	?   $tests[0]{OUTPUT}[0] eq 'ARRAY' 
	    ? '\@results'
	    : '@results'
	: '$result';

    my %substitutions = (
	CHALLENGE    => $challenge,
	TASK_NUMBER  => $task,
	TASK_NAME    => $task_name,
	SUB_NAME     => $sub_name,
	INPUT_PARAMS => $input_params,
	RESULT_VAR   => $result_var,
	RETURN       => $return,
    );
    $code =~ s/<$_>/$substitutions{$_}/g
	for keys %substitutions;

    # vsay $code;
    return $code;
}

sub generate_readme_md( $challenge, $text ) {

    my ( $task_1_name, $task_1_text, $task_2_name, $task_2_text ) =
	$text =~ /^Task\s+1: \s* (.*?) \s*$ \n
		  ^Submitted .*? $ \n
		  \s*? \n
	          ( ^\S.*?$
		      (?: \n ^.*?$ )*? ) \n
		  (?:^\s* $ \n )*
		  ^Example  .*? $ \n
		  (?:^\s* $ \n )*
		  ^Task\s+2: \s* (.*?) \s*$ \n
		  ^Submitted .*? $ \n
		  \s*? \n
	          ( ^\S.*?$
		      (?: \n ^.*?$ )*? ) \n
		  (?:^\s* $ \n )*
		  ^Example  .*? $ \n
		  (?:^\s* $ \n )*
		  ^Last \s+ date \s+ to \s+ submit
	    /xms;
    # vsay "task_1_name: ", pp $task_1_name;
    # vsay "task_1_text: ", pp $task_1_text;
    # vsay "task_2_name: ", pp $task_2_name;
    # vsay "task_2_text: ", pp $task_2_text;

    my $readme_text = $templates->{readme}{'readme_md'};
    # vsay $readme_text;
    my %substitutions = (
	CHALLENGE          => $challenge,
	TASK_1_NAME        => $task_1_name,
	TASK_1_TEXT_QUOTE  => $task_1_text =~ s/^(.*)$/> $1<br\/>/mgr,
	TASK_2_NAME        => $task_2_name,
	TASK_2_TEXT_QUOTE  => $task_2_text =~ s/^(.*)$/> $1<br\/>/mgr,
    );
    $readme_text =~ s/<$_>/$substitutions{$_}/g
	for keys %substitutions;

    # vsay $readme_text;
    return $readme_text;
}

sub slurp_file( $file ) {
    open my $fh, "<", $file
	or die "cannot open '$file': $!\n";
    my $text = do { local $/ = undef; <$fh> };
    close $fh;
    return $text;
}

sub spit_file( $file, $text ) {
    open my $fh, ">", $file
	or die "cannot open '$file' for writing: $!\n";
    print $fh $text;
    close $fh;
}

sub time_string( $time ) {
    my $time_struct = localtime( $time );
    my $time_string = $time_struct->strftime( "%FT%T%z" );
    # Insert a ':' between the time zone hours and minutes to be RFC 3339
    # compatible (which is what TOML promotes), even if ISO allows time zones
    # without ':'. Actually with no real effect, since Perl TOML doesn't
    # convert datetime strings if no 'inflate_datetime' subroutine is given
    # to the TOML parser. So we will get the string back that we store.
    $time_string =~ s/(?=\d{2}$)/:/;
    return $time_string;
}

sub read_toml( $filename ) {
    my $toml_text = slurp_file( $filename );
    my $hash_ref = TOML::from_toml( $toml_text );
    # Keep the filename and the toml text for later writing back the file.
    @$hash_ref{ qw( TOML_FILE TOML_TEXT ) } = ( $filename, $toml_text );
    return $hash_ref;
}

sub write_toml( $hash_ref ) {
    my ( $filename, $toml_text ) = @$hash_ref{ qw( TOML_FILE TOML_TEXT ) };
    # Update the toml file if needed.
    spit_file( $filename, $toml_text )
	if $hash_ref->{TOML_CHANGED} && ! $options{DRY_RUN};
    delete $hash_ref->{TOML_CHANGED};
}

sub set_toml( $hash_ref, $name, $value ) {
    $hash_ref->{$name} = $value;
    $hash_ref->{TOML_TEXT} =~ s/^(\s* ${name} \s* = \s* ).*?$/${1}"${value}"/xm;
    $hash_ref->{TOML_CHANGED} = 1;
}

sub timestamp {
    use POSIX qw(strftime);
    return strftime "%y%m%d_%H%M%S", localtime;
}

1;
