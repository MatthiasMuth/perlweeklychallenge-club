#!/usr/bin/env perl
#
#	download_challenge [<challenge> ...]
#		checks whether there is a new weekly challenge, extracts
#		the new task descriptions if so,
#		writes them as ascii into a text file,
#		and sends them via HTML email.
#		It also generates template files for perl/ch-[12].pl based on
#		the challenge task descriptions.
#
#	Usage:
#	    get_weekly_challenge
#		Without parameters, executes these default tasks:
#		  * retrieve the task descriptions for the most recent weekly
#		    challenge from the Weekly Challenge website.
#	        If the challenge number or the task descriptions have changed:
#		  * write a text file 'challenge-<challenge>.txt' containing the
#		    task descriptions in the
#		    .../challenge-<challenge>/<user>/perl directory,
#		    if the task descriptions have changed,
#		    (where <user> is the challenge user name, as specified in
#		    the 'status.toml' file),
#		  * send the task descriptions as html email to a default list
#		    of recipients (specified in 'status.toml').
#		  * generate template files for .../perl/ch-[12].pl based on
#		    the challenge task descriptions, if they do not yet exist.
#
#	    get_weekly_challenge <challenge> ...
#		When challenge numbers are explicitly given as command line
#		parameters, only these steps are done by default:
#		  * retrieve the task descriptions for the given challenges,
#		  * write the task text files if they have changed,
#		  * generate the code template files if they do not yet exist.
#		No mail is sent unless the -mail <recipient> option is
#		given explicitly.
#
#	Options:
#	    -nofiles | -nof
#	        Do not write any output files.
#	    -mail <recipient>
#		Send mail (or mails) to <recipient>.
#		The default list of recipients is not used if this option is
#		given.
#		This option can be used multiple times.
#	    -nomail | -nom
#		Do not send any default emails.
#

use strict;
use warnings;

use M;
use Getopt::Long;
use TOML;
use Time::Piece;

use LWP::Simple;
use HTML::TreeBuilder::XPath;
use URI::Escape;
use Encode;

use File::Basename;
use File::Path qw( make_path );

use Digest::MD5 qw( md5_hex );
use Email::Stuffer;


sub usage {
    say STDERR "Usage!";
    exit 2;
};

GetOptions(
    "force|f!"               => \$options{FORCE},
    "check|n"                => \$options{DRY_RUN},
    "mail|m:s@"              => \$options{MAIL_TO},
    "nomail|nom"             => sub {
				    # Make sure it's defined but empty.
				    $options{MAIL_TO} = [];
				},
    "nofile|nof"             => \$options{NO_FILE},
    "quiet|q!"               => \$options{QUIET},
    "verbose|v!"             => \$verbose,
    "help|?"                 => \&usage,
) or do {
    say STDERR
        "    Use '$0 -help' for usage information.";
    exit 2;
};

# Read 'status.toml' and templates, keep it as a global variable.
our $status   = read_toml( "status.toml" );
our $template = read_toml( "template.toml" );

# Defaults:
unless ( @ARGV ) {
    # We use the following option to decide whether to always send mails
    # or only when there was a change.
    $options{MAIL_ONLY_FOR_UPDATES} = 1;

    # Send mail to default recipients if no challenge arguments are given.
    $options{MAIL_TO} //= $status->{'recipients'};
}

process_challenge( $_ )
    for @ARGV ? @ARGV : get_challenge_update();

# Update the status toml file.
write_toml( $status )
    unless $options{DRY_RUN};

exit 0;

sub process_challenge( $challenge ) {

    # Extract the interesting portion from the challenge page.
    my $title = "Perl Weekly Challenge $challenge";

    # Extract relevant HTML parts (page header and task descriptions)
    # from the challenge page.
    my ( $main_url, $challenge_path ) =
	@$status{ qw( main-url challenge-path ) };
    $challenge_path =~ s/\d+/$challenge/;
    my $html = get( $main_url . $challenge_path );
    my ( $page_header ) = 
	$html =~ m'(<section class="global-page-header">.*?</section>)'s;
    my ( $tasks ) =
	$html =~ m'(<h2 id="TASK1">.*?</section>)'s;

    # Create the mail html from the template,
    # copying in the extracted HTML parts.
    $html = $template->{'mail'}{'html'};
    my %substitutions = (
	CHALLENGE   => $challenge,
	PAGE_HEADER => $page_header,
	TASKS       => $tasks,
    );
    $html =~ s/<$_>/$substitutions{$_}/g
	for keys %substitutions;
    # vsay "html\n", $html;

    unless ( $html ) {
	say STDERR "ERROR: html is empty. Aborting.";
	exit 1;
    }

    # Send mails.
    if ( $options{MAIL_TO} && @{$options{MAIL_TO}} ) {
	# For updates, send mails only if the html text has changed.
	my $send_html = 1;
	if ( $options{MAIL_ONLY_FOR_UPDATES} ) {
	    if ( ( my $md5 = md5_hex( $html ) )
		eq $status->{'challenge-html-md5'} )
	    {
		prot "Challenge page modified,"
		    . " but task description unchanged."
		    unless $options{QUIET};
		$send_html = 0;
	    }
	    else {
		vsay "html md5 has changed";
		set_toml( $status, 'challenge-html-md5', $md5 );
	    }
	}

	if ( $send_html ) {
	    for my $rcpt ( @{$options{MAIL_TO}} ) {
		if ( $options{DRY_RUN} ) {
		    say "not sending email to $rcpt"
			unless $options{QUIET};
		}
		else {
		    vsay "sending email to $rcpt";
		    Email::Stuffer
			->from( 'muthm@muthnet.de' )
			->to( $rcpt )
			->subject( $title )
			->html_body( $html )
			->send_or_die;
		    prot "Sent email to $rcpt"
			unless $options{QUIET};
		}
	    }
	}
    }

    # Write files.
    unless ( $options{NO_FILE} ) {
	my $tree = HTML::TreeBuilder::XPath->new( ignore_unknown => 0 );

	$tree->parse_content( $html )
	    or die "ERROR: could not parse html data.\n";

	# Extract nodes containing the title and the date,
	# followed by two <br> to create empty lines,
	# followed by everything inside the <div class="post-content"> block,
	# individually.
	my @nodes = map $tree->findnodes( $_ ),
	    qw(
		//section[@class="global-page-header"]//h2
		//div[@class="block"]//span[1]
		//br[1]
		//br[1]
		//div[@class="post-content"]/*
	    );

	# Extract the text from the nodes.
	# Ignore <hr> to avoid empty lines where they are not needed.
	# Instead add an extra empty line after <h4> ('Example...') and
	# <h5> ('submitted by'). 
	my $challenge_text = join "",
	    map { $_->as_text . "\n" . ( $_->{_tag} =~ /^h[45]/ ? "\n" : "" ) }
	        grep $_->{_tag} ne "hr", @nodes;

	my ( $task_1, $task_2 ) = $challenge_text =~ /(^Task 1.*)(^Task 2.*)/ms;

	# Generate the code templates.
	my ( $task_1_code, $task_2_code ) =
	    map generate_code( $challenge, $_ ), ( $task_1, $task_2 );
	
	# Write out the task descriptions,
	# and write out the code files if the do not exist yet.
	my $target_dir = "../challenge-$challenge/$status->{user}/perl";
	vsay $options{DRY_RUN} ? "not " : "",
	    "writing '$target_dir/challenge-$challenge.txt'";
	unless ( $options{DRY_RUN} ) { 
	    make_path $target_dir;
	    spit_file( "$target_dir/challenge-$challenge.txt",
		$challenge_text );
	    spit_file( "$target_dir/ch-1.pl", $task_1_code )
	        unless -f "$target_dir/ch-1.pl";
	    spit_file( "$target_dir/ch-2.pl", $task_2_code )
	        unless -f "$target_dir/ch-2.pl";
	}
    }
}

exit 0;

sub retrieve_challenge_link( $base_url, $pattern ) {
    my $tree = HTML::TreeBuilder::XPath->new_from_url( $base_url )
	or die "ERROR: could not retrieve data from $base_url.\n";
    my $xpath  = "//\@href[.=~/$pattern/";
    my $link = $tree->findvalue( $xpath )
	or die "ERROR: did not find xpath '$xpath' in data.\n";
    return $link;
}

sub get_challenge_update {

    my ( $challenge ) = $status->{'challenge-path'} =~ /(\d+)/;

    # Step 1:
    # Determine the current challenge number:
    # Check whether the main page was modified.
    # Update to the current challenge number if it has.
    # If no change was detected, use what we have cached in status.toml.

    my $main_url = $status->{'main-url'};
    my $challenge_path = $status->{'challenge-path'};
    if ( check_page_change( $main_url, 'main-last-modified' ) ) {
	my $xpath_pattern  = '\/blog\/perl-weekly-challenge-\\d+';
	$challenge_path = retrieve_challenge_link( $main_url, $xpath_pattern );
	vsay "challenge-path: ", pp( $challenge_path );
	unless ( $challenge_path ) {
	    say STDERR "ERROR: Could not extract challenge url. Aborting.";
	    exit 1;
	}

	if ( $challenge_path ne $status->{'challenge-path'} ) {
	    ( $challenge ) = $challenge_path =~ /(\d+)$/;
	    prot "New challenge $challenge detected."
		unless $options{QUIET};
	    set_toml( $status, "challenge-path", $challenge_path );
	    set_toml( $status, "challenge-last-modified", "" );
	}
	else {
	    vsay "challenge url has not changed";
	}
    }
    else {
	vsay "main page was not modified";
    }

    # Step 2:
    # Check the challenge page for modification.
    if ( ! check_page_change(
	$main_url . $challenge_path, 'challenge-last-modified' ) )
    {
        vsay "challenge page was not modified";
	$challenge = undef;
    }
    else {
	vsay "challenge page was modified";
    }

    return $challenge // ();
}

sub check_page_change( $url, $last_modified_field_name ) {
    my @header = head( $url );
    my $modified_time = time_string( $header[2] );
    vsay "modified_time: ", pp( $modified_time );
    if ( $status->{$last_modified_field_name} 
	&& $modified_time eq $status->{$last_modified_field_name} )
    {
	# vsay "'$url' was not modified";
	return ()
	    unless $options{FORCE};
    }
    set_toml( $status, $last_modified_field_name, $modified_time );
    return 1;
}

sub generate_code( $challenge, $text ) {

    my ( $task, $task_name ) = $text =~ /^Task (\d+):\s*(.*?)\s*$/m;

    use TestExtractor;
    my @tests = TestExtractor::extract_tests( $text );

    my $code = $template->{code}{'ch-N_pl'};
    ( my $sub_name = lc $task_name ) =~ s/\W+/_/g;
    my @input_vars = @{$tests[0]{VARIABLE_NAMES}};

    # Turn array parameters into arrayrefs in some cases.
    if ( @input_vars > 1
	|| ref $tests[0]{INPUT}[0] eq 'ARRAY'
	    && ref $tests[0]{INPUT}[0][0] eq 'ARRAY' )
    {
	substr $_, 0, 1, '$'
	    for @input_vars;
    }
    my $input_params = join ", ", @input_vars;
    my $result_var = 
	ref $tests[0]{OUTPUT} eq 'ARRAY'
	? '@results'
	: '$result';
    my $return = 
	ref $tests[0]{OUTPUT} eq 'ARRAY'
	?   $tests[0]{OUTPUT}[0] eq 'ARRAY' 
	    ? '\@results'
	    : '@results'
	: '$result';

    my %substitutions = (
	CHALLENGE    => $challenge,
	TASK_NUMBER  => $task,
	TASK_NAME    => $task_name,
	SUB_NAME     => $sub_name,
	INPUT_PARAMS => $input_params,
	RESULT_VAR   => $result_var,
	RETURN       => $return,
    );
    $code =~ s/<$_>/$substitutions{$_}/g
	for keys %substitutions;

    # vsay $code;
    return $code;
}

sub slurp_file( $file ) {
    open my $fh, "<", $file
	or die "cannot open '$file': $!\n";
    my $text = do { local $/ = undef; <$fh> };
    close $fh;
    return $text;
}

sub spit_file( $file, $text ) {
    open my $fh, ">", $file
	or die "cannot open '$file' for writing: $!\n";
    print $fh $text;
    close $fh;
}

sub time_string( $time ) {
    my $time_struct = localtime( $time );
    my $time_string = $time_struct->strftime( "%FT%T%z" );
    # Insert a ':' between the time zone hours and minutes to be RFC 3339
    # compatible (which is what TOML promotes), even if ISO allows time zones
    # without ':'. Actually with no real effect, since Perl TOML doesn't
    # convert datetime strings if no 'inflate_datetime' subroutine is given
    # to the TOML parser. So we will get the string back that we store.
    $time_string =~ s/(?=\d{2}$)/:/;
    return $time_string;
}

sub read_toml( $filename ) {
    my $toml_text = slurp_file( $filename );
    my $hash_ref = TOML::from_toml( $toml_text );
    # Keep the filename and the toml text for later writing back the file.
    @$hash_ref{ qw( TOML_FILE TOML_TEXT ) } = ( $filename, $toml_text );
    return $hash_ref;
}

sub write_toml( $hash_ref ) {
    my ( $filename, $toml_text ) = @$hash_ref{ qw( TOML_FILE TOML_TEXT ) };
    # Update the toml file if needed.
    spit_file( $filename, $toml_text )
	if $hash_ref->{TOML_CHANGED} && ! $options{DRY_RUN};
    delete $hash_ref->{TOML_CHANGED};
}

sub set_toml( $hash_ref, $name, $value ) {
    $hash_ref->{$name} = $value;
    $hash_ref->{TOML_TEXT} =~ s/^(\s* ${name} \s* = \s* ).*?$/${1}"${value}"/xm;
    $hash_ref->{TOML_CHANGED} = 1;
}

1;
