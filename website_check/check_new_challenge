#!/usr/bin/perl -w
#
#	get_weekly_challenge -
#		extract the current challenge from the
#		https://theweeklychallenge.org/ website,
#		and send a mail if it has changed.

use strict;
use warnings;

use M;
use Getopt::Long;
use TOML;
use Time::Piece;

use LWP::Simple;
use HTML::TreeBuilder::XPath;
use URI::Escape;
use Encode;

use File::Basename;

use Email::Stuffer;

sub usage {
    say STDERR "Usage!";
    exit 2;
};

GetOptions(
    "force|f!"               => \$options{FORCE},
    "check|n"                => \$options{DRY_RUN},
    "mail|m:s@"              => \$options{MAIL_TO},
    "nomail|nom"             => sub {
				    # Make sure it's defined but empty.
				    $options{MAIL_TO} = [];
				},
    "quiet|q!"               => \$options{QUIET},
    "verbose|v!"             => \$verbose,
    "log:s"                  => \$options{LOGFILE},
    "debug:s"                => \&CDE::get_debug_options,
    "help|?"                 => \&usage,
) or do {
    say STDERR
        "    Use '$0 -help' for usage information.";
    exit 2;
};

# Defaults:
$options{MAIL_TO} //= [
    'muthm@gmx.de',
];

my $toml_file = "status.toml";
my $toml = slurp_file( $toml_file );
my $status = TOML::from_toml( $toml );
# vsay pp( $status );
vsay "status.last-modified: ", pp( $status->{'last-modified'} );


my $url = $status->{url};
my @header = head( $url );
my $modified_time = $header[2];
$modified_time = localtime( $modified_time );
$modified_time = $modified_time->strftime( "%FT%T%z" );
$modified_time =~ s/(?=\d{2}$)/:/;
vsay "modified_time: ", pp( $modified_time );

if ( $modified_time eq $status->{'last-modified'} ) {
    vsay "Modified_time has not changed. Exiting.";
    exit 0
        unless $options{FORCE};
}

my $xpath_pattern  = '\/blog\/perl-weekly-challenge-\\d+';
my $link = get_href( $url, $xpath_pattern );
vsay "challenge link: ", pp( $link );
unless ( $link ) {
    say STDERR "ERROR: Could not extract challenge link. Aborting.";
    exit 1;
}
 
if ( $link eq $status->{link} ) {
    # Update the status toml file.
    $toml =~ s/^(\s* last-modified \s* = \s* ).*?$/${1}${modified_time}/xm;
    spit_file( $toml_file, $toml )
	unless $options{DRY_RUN};

    vsay "Link to challenge page has not changed. Exiting.";
    exit 0
        unless $options{FORCE};
}

my ( $challenge ) = $link =~ /(\d+)$/;
prot "New challenge $challenge detected."
    unless $options{QUIET};

# Extract the interesting portion from the challenge page.
my $title = "Perl Weekly Challenge $challenge";

# Get variable HTML parts from the challenge page.
my $html = get( "$url/$link" );
# my $html = slurp_file( "challenge.html" );

my ( $page_header ) = 
    $html =~ m'(<section class="global-page-header">.*?</section>)'s;
# vsay "page_header:\n", $page_header;

my ( $tasks ) =
    $html =~ m'(<h2 id="TASK1">.*?</section>)'s;
# vsay "tasks:\n", pp( $tasks );

$html = join "\n",
    $status->{mail}{'document-start'},
    ${page_header},
    $status->{mail}{'section-start'},
    ${tasks},
    $status->{mail}{'document-end'};
# vsay "html\n", $html;

# Send mail.
if ( $html && $options{MAIL_TO} ) {
    for my $rcpt ( @{$options{MAIL_TO}} ) {
	if ( $options{DRY_RUN} ) {
	    say "Send email to $rcpt"
		unless $options{QUIET};
	}
	else {
	    vsay "Sending email to $rcpt";
	    Email::Stuffer
		->from( 'muthm@muthnet.de' )
		->to( $rcpt )
		->subject( $title )
		->html_body( $html )
		->send_or_die;
	    prot "Sent email to $rcpt"
		unless $options{QUIET};
	}
    }
}

# Update the status toml file.
$toml =~ s/^(\s* last-modified \s* = \s* ).*?$/${1}${modified_time}/xm;
$toml =~ s/^(\s* link \s* = \s* ).*?$/${1}"${link}"/xm;
spit_file( $toml_file, $toml )
    unless $options{DRY_RUN};

exit 0;

sub slurp_file( $file ) {
    open my $fh, "<", $file
	or die "cannot open '$file': $!\n";
    my $text = do { local $/ = undef; <$fh> };
    close $fh;
    return $text;
}

sub spit_file( $file, $text ) {
    open my $fh, ">", $file
	or die "cannot open '$file' for writing: $!\n";
    print $fh $text;
    close $fh;
}

sub get_href( $base_url, $pattern ) {
    my $tree = HTML::TreeBuilder::XPath->new_from_url( $base_url )
	or die "ERROR: could not retrieve data from $base_url.\n";
    my $xpath  = "//\@href[.=~/$pattern/";
    my $link = $tree->findvalue( $xpath )
	or die "ERROR: did not find xpath '$xpath' in data.\n";
    return $link;
}

1;
